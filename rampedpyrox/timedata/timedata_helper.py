'''
This module contains helper functions for timedata classes.
'''

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from scipy.interpolate import interp1d

#helper functions

#define function to pull plotting dicts
def _plot_dicts(case, td):
	'''
	Function to access different plotting dicts.

	Parameters
	----------
	case : str
		The case that defines the dict to pull.
		Acceptable strings:
			'rpo_rd',
			'rpo_labs',
			'rpo_md'

	td : TimeData or subclass
		``TimeData`` instance containing the data to plot

	Returns
	-------
	pl_dict : dict
		The resulting dictionary containing plotting info.
	'''

	if case == 'rpo_md':
		#create a nested dict to keep track of cases of modeled data
		pl_dict = {'time': {'fraction' : (td.t, td.gam, td.cmpt),
						'rate' : (td.t, -td.dgamdt, -td.dcmptdt)},
			'temp': {'fraction' : (td.T, td.gam, td.cmpt),
						'rate' : (td.T, -td.dgamdT, -td.dcmptdT)}}

	elif case == 'rpo_labs':
		#create a nested dict to keep track of axis labels
		pl_dict = {'time': {'fraction' : ('time (s)', 'g (unitless)'),
						'rate' : ('time (s)', r'fraction/time $(s^{-1})$')},
			'temp' : {'fraction' : ('temp (K)', 'g (unitless)'),
						'rate' : ('temp (K)', r'fraction/temp $(K^{-1})$')}}

	elif case == 'rpo_rd':
		#create a nested dict to keep track of cases for real data
		pl_dict = {'time': {'fraction' : (td.t, td.g),
						'rate' : (td.t, -td.dgdt)},
			'temp': {'fraction' : (td.T, td.g),
						'rate' : (td.T, -td.dgdT)}}

	return pl_dict

#define function to remove duplicate legend entries
def _rem_dup_leg(ax):
	'''
	Removes duplicate legend entries.

	Parameters
	----------
	ax : plt.axishandle
		Axis handle containing entries to remove.

	Returns
	-------
	han_list : list
		List of axis handles.

	lab_list : list
		List of axis handle labels.
	'''
	han, lab = ax.get_legend_handles_labels()
	han_list, lab_list = [], []
	
	for h, l in zip(han, lab):
		if l not in lab_list:
			han_list.append(h)
			lab_list.append(l)

	return han_list, lab_list

#define function to extract variables from .csv file
def _rpo_extract_tg(file, nt, err):
	'''
	Extracts time, temperature, and carbon remaining vectors from `all_data`
	file generated by NOSAMS RPO LabView program (VERSION XXX).

	Parameters
	----------
	file : str or pd.DataFrame 
		File containing thermogram data, either as a path string or 
		``pd.DataFrame`` instance.

	nT : int 
		The number of time points to use. Defaults to 250.

	ppm_CO2_err : int or float
		The CO2 concentration standard deviation, in ppm. Used to 
		calculate `g_std`.

	Returns
	-------
	g : np.ndarray
		Array of the true fraction of carbon remaining at each timepoint.
		Length nt.

	g_std : np.ndarray
		Array of the standard deviation of `g`. Length nt.
	
	t : np.ndarray
		Array of timep, in seconds. Length nt.

	T : np.ndarray
		Array of temperature, in Kelvin. Length nt.

	Raises
	------
	TypeError
		If `file` is not str or ``pd.DataFrame`` instance.
	
	TypeError
		If index of `file` is not ``pd.DatetimeIndex`` instance.

	TypeError
		If `nt` is not int.

	ValueError
		If `file` does not contain "CO2_scaled" and "temp" columns.
	'''

	#check data format and raise appropriate errors
	if isinstance(file, str):
		#import as dataframe
		file = pd.read_csv(file,
			index_col=0,
			parse_dates=True)

	elif not isinstance(file, pd.DataFrame):
		raise TypeError('file must be pd.DataFrame instance or path string')

	if 'CO2_scaled' and 'temp' not in file.columns:
		raise ValueError('file must have "CO2_scaled" and "temp" columns')

	elif not isinstance(file.index, pd.DatetimeIndex):
		raise TypeError('file index must be pd.DatetimeIndex instance')

	#extract necessary data
	secs = (file.index - file.index[0]).seconds
	CO2 = file.CO2_scaled
	tot = np.sum(CO2)
	Temp = file.temp

	#calculate alpha and stdev bounds
	alpha = np.cumsum(CO2)/tot
	alpha_p = np.cumsum(CO2+err)/tot
	alpha_m = np.cumsum(CO2-err)/tot

	#generate t array
	t0 = secs[0]; tf = secs[-1]; dt = (tf-t0)/nt
	t = np.linspace(t0,tf,nt+1) + dt/2 #make downsampled points at midpoint
	t = t[:-1] #drop last point since it's beyond tf

	#generate functions to down-sample
	fT = interp1d(secs, Temp)
	fg = interp1d(secs, alpha)
	fg_p = interp1d(secs, alpha_p)
	fg_m = interp1d(secs, alpha_m)
	
	T = fT(t) + 273.15 #convert to K
	g = 1-fg(t)
	g_std = 0.5*(fg_p(t) - fg_m(t))
	
	return g, g_std, t, T

